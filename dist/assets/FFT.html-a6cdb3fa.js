import{_ as a,a as n,b as s}from"./math_16-d71d01a1.js";import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as p,c as o,f as c}from"./app-1ed3f6c2.js";const e={},i=c('<h1 id="fft快速傅里叶" tabindex="-1"><a class="header-anchor" href="#fft快速傅里叶" aria-hidden="true">#</a> FFT快速傅里叶</h1><p>多项式乘法<br> 给定一个<img src="https://math.jianshu.com/math?formula=n" alt="n">次多项式<img src="https://math.jianshu.com/math?formula=A(x)" alt="A(x)">和<img src="https://math.jianshu.com/math?formula=m" alt="m">次多项式<img src="https://math.jianshu.com/math?formula=B(n)" alt="B(n)">，求出<img src="https://math.jianshu.com/math?formula=F(x)" alt="F(x)">与<img src="https://math.jianshu.com/math?formula=G(x)" alt="G(x)">的卷积。</p><h2 id="输入格式" tabindex="-1"><a class="header-anchor" href="#输入格式" aria-hidden="true">#</a> 输入格式</h2><p>第一行两个整数<img src="https://math.jianshu.com/math?formula=n%2Cmn%2Cm" alt="n,mn,m">。<br> 接下来一行<img src="https://math.jianshu.com/math?formula=n%2B1" alt="n+1">个数字，从低到高表示<img src="https://math.jianshu.com/math?formula=F(x)" alt="F(x)">的系数。<br> 接下来一行<img src="https://math.jianshu.com/math?formula=m%2B1" alt="m+1">个数字，从低到高表示<img src="https://math.jianshu.com/math?formula=G(x)" alt="G(x)">的系数。</p><h2 id="输出格式" tabindex="-1"><a class="header-anchor" href="#输出格式" aria-hidden="true">#</a> 输出格式</h2><p>一行<img src="https://math.jianshu.com/math?formula=n%2Bm%2B1" alt="n+m+1">个数字，从低到高表示<img src="https://math.jianshu.com/math?formula=F(x) \\cdot G(x)" alt="F(x) dot G(x)">的系数。</p><h2 id="输入输出样例" tabindex="-1"><a class="header-anchor" href="#输入输出样例" aria-hidden="true">#</a> 输入输出样例</h2><h3 id="输入样例" tabindex="-1"><a class="header-anchor" href="#输入样例" aria-hidden="true">#</a> 输入样例</h3><blockquote><p>1 2<br> 1 2<br> 1 2 1</p></blockquote><h3 id="输出样例" tabindex="-1"><a class="header-anchor" href="#输出样例" aria-hidden="true">#</a> 输出样例</h3><blockquote><p>1 4 5 2</p></blockquote><h1 id="问题分析" tabindex="-1"><a class="header-anchor" href="#问题分析" aria-hidden="true">#</a> 问题分析</h1><p>假设两个多项式<img src="https://math.jianshu.com/math?formula=A(x)%3Da_0%2Ba_1x%2Ba_2x^2%2B\\cdots %2Ba_{n-1}x_{n-1}" alt="A(x)=a_0+a_1x+a_2x^2+dots +a_{n-1}x_{n-1}">和<img src="https://math.jianshu.com/math?formula=B(x)%3Db_0%2Bb_1x%2Bb_2x^2%2B\\cdots %2Bb_{n-1}x^{n-1}" alt="B(x)=b_0+b_1x+b_2x^2+dots +b_{n-1}x^{n-1}">，两个多项式可以写作：<br><img src="https://math.jianshu.com/math?formula=\\begin{equation} A(x)%3D\\sum_{i%3D0}^{n-1}a_ix^i\\\\ B(x)%3D\\sum_{i%3D0}^{n-1}a_ix^i \\end{equation}" alt="egin{equation} A(x)=um_{i=0}{n-1}a_ixi B(x)=um_{i=0}{n-1}a_ixi nd{equation}"><br> 传统方法是利用两个多项式的系数进行卷积运算，得到一个<img src="https://math.jianshu.com/math?formula=2n-2" alt="2n-2">次多项式<img src="https://math.jianshu.com/math?formula=C(x)" alt="C(x)">：<br><img src="https://math.jianshu.com/math?formula=\\begin{equation} C(x)%3D\\sum_{i%3D0}^{2n-2}c_ix_i \\end{equation}" alt="egin{equation} C(x)=um_{i=0}^{2n-2}c_ix_i nd{equation}"><br> 这种卷积运算的时间复杂度为<img src="https://math.jianshu.com/math?formula=O(n^2)" alt="O(n^2)">，显然在数据范围较大的情况下难以承受，而利用<strong>快速傅里叶变换</strong>可将时间复杂度降为<img src="https://math.jianshu.com/math?formula=O(nlogn)" alt="O(nlogn)">。</p><h1 id="fft介绍" tabindex="-1"><a class="header-anchor" href="#fft介绍" aria-hidden="true">#</a> FFT介绍</h1><blockquote><p>快速傅里叶变换 (fast Fourier transform),即利用计算机计算离散傅里叶变换（DFT)的高效、快速计算方法的统称，简称FFT。快速傅里叶变换是1965年由J.W.库利和T.W.图基提出的。采用这种算法能使计算机计算离散傅里叶变换所需要的乘法次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。<br> FFT（Fast Fourier Transformation） 是离散傅氏变换（DFT）的快速算法。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。<br> ——百度百科</p></blockquote><p>要解决的问题是多项式的乘法，而一个多项式的表示方法并不唯一，传统意义上多项式的表示利用的是系数表示法，即对于一个多项式<img src="https://math.jianshu.com/math?formula=A(x)%3Da_0%2Ba_1x%2Ba_2x^2%2B\\cdots %2Ba_{n-1}x_{n-1}" alt="A(x)=a_0+a_1x+a_2x^2+dots +a_{n-1}x_{n-1}">可由一个系数向量<img src="https://math.jianshu.com/math?formula=(a_0%2Ca_1%2Ca_2%2C\\cdots%2Ca_{n-1})" alt="(a_0,a_1,a_2,dots,a_{n-1})">唯一表示。</p><p>而除了系数表示法之外，多项式也可以利用点值表示，对于多项式<img src="https://math.jianshu.com/math?formula=A(x)" alt="A(x)">，选定<img src="https://math.jianshu.com/math?formula=n" alt="n">个<img src="https://math.jianshu.com/math?formula=x" alt="x">值<img src="https://math.jianshu.com/math?formula=(x_0%2Cx_1%2Cx_2%2C\\cdots%2Cx_{n-1})" alt="(x_0,x_1,x_2,dots,x_{n-1})">带入多项式进行计算，得到<img src="https://math.jianshu.com/math?formula=n" alt="n">个点值)这<img src="https://math.jianshu.com/math?formula=n" alt="n">个点值也可唯一表示多项式<img src="https://math.jianshu.com/math?formula=A(x)" alt="A(x)">。</p><p>因此当我们利用同一个向量<img src="https://math.jianshu.com/math?formula=x" alt="x">得到了两个两个多项式的点值表示法后，用对应点值相乘，得到<img src="https://math.jianshu.com/math?formula=(A(x_0)B(x_0)%2CA(x_1)B(x_1)%2CA(x_2)B(x_2)%2C\\cdots%2CA(x_{n-1})B(x_{n-1}))" alt="(A(x_0)B(x_0),A(x_1)B(x_1),A(x_2)B(x_2),dots,A(x_{n-1})B(x_{n-1}))">即为两个多项式的乘积多项式的点值表示，这个过程的时间复杂度为<img src="https://math.jianshu.com/math?formula=O(n)" alt="O(n)">。</p><p>需要注意的一点是，当两个多项式次数为<img src="https://math.jianshu.com/math?formula=n%2Cm" alt="n,m">时，他们的乘积多项式次数为<img src="https://math.jianshu.com/math?formula=n%2Bm" alt="n+m">，因此利用点值表示计算时，计算两个多项式的点值表示时应选用<img src="https://math.jianshu.com/math?formula=n%2Bm%2B1" alt="n+m+1">个变量，才能使得到的结果唯一表示乘积多项式<img src="https://math.jianshu.com/math?formula=C(x)" alt="C(x)">。</p><p>然而对于一个多项式<img src="https://math.jianshu.com/math?formula=A(x)" alt="A(x)">来说，代入任意选定的变量<img src="https://math.jianshu.com/math?formula=(x_0%2Cx_1%2Cx_2%2C\\cdots%2Cx_{n-1})" alt="(x_0,x_1,x_2,dots,x_{n-1})">计算他的点值表示法时间复杂度依然是<img src="https://math.jianshu.com/math?formula=O(n^2)" alt="O(n^2)">，并没有起到优化的效果，而快速傅里叶变换解决了这个问题，使得系数表示法转化为点值表示法的时间复杂度降低为<img src="https://math.jianshu.com/math?formula=O(nlogn)" alt="O(nlogn)">。</p><h3 id="快速傅里叶变换fft" tabindex="-1"><a class="header-anchor" href="#快速傅里叶变换fft" aria-hidden="true">#</a> 快速傅里叶变换FFT</h3><p>FFT在计算多项式的系数表示法变换为点值表示法时，选定<strong>复平面</strong>上单位圆上的<strong>单位复根</strong><img src="https://math.jianshu.com/math?formula=\\omega_n^k" alt="mega_n^k">作为变量计算多项式的点值，在这里单位根<img src="https://math.jianshu.com/math?formula=\\omega_n^k" alt="mega_n^k">满足以下的一些性质（如果有不理解的可以自行查阅复数的一些相关知识)：</p><div style="text-align:center;"><img src="'+a+'" alt="ASIC Flow" width="200"><h4>图1 FFT</h4></div><p>以上的这些性质都可以由<strong>Euler公式</strong>得到，推导过程并非FFT重点这里就省略了。</p><p>对于一个多项式<img src="https://math.jianshu.com/math?formula=A(x)%3Da_0%2Ba_1x%2Ba_2x^2%2B\\cdots %2Ba_{n-1}x_{n-1}" alt="A(x)=a_0+a_1x+a_2x^2+dots +a_{n-1}x_{n-1}">，我们可以对其进行划分，将偶数次项与奇数次项分开，在这里假设<img src="https://math.jianshu.com/math?formula=n-1" alt="n-1">为奇数，得到：<br><img src="https://math.jianshu.com/math?formula=A(x)%3D(a_0%2Ba_2x^2%2B\\cdots %2Ba_{n-2}x^{n-2})%2Bx(a_1%2Ba_3x^2%2B\\cdots %2Ba_{n-1}x^{n-2})" alt="A(x)=(a_0+a_2x^2+dots +a_{n-2}x{n-2})+x(a_1+a_3x2+dots +a_{n-1}x^{n-2})"><br> 我们分别定义两个多项式<img src="https://math.jianshu.com/math?formula=A_1(x)%2CA_2(x)" alt="A_1(x),A_2(x)">：<br><img src="https://math.jianshu.com/math?formula=\\begin{aligned} %26A_1(x)%3Da_0%2Ba_2x^1%2B\\cdots %2Ba_{n-2}x^{\\frac{n}{2}-1}\\\\ %26A_2(x)%3Da_1%2Ba_3x^2%2B\\cdots %2Ba_{n-1}x^{\\frac{n}{2}-1}\\\\ \\end{aligned}" alt="egin{aligned} &amp;A_1(x)=a_0+a_2x^1+dots +a_{n-2}x^{rac{n}{2}-1} &amp;A_2(x)=a_1+a_3x^2+dots +a_{n-1}x^{rac{n}{2}-1} nd{aligned}"><br> 那么原多项式<img src="https://math.jianshu.com/math?formula=A(x)" alt="A(x)">就可以表示为：<br><img src="https://math.jianshu.com/math?formula=A(x)%3DA_1(x^2)%2BxA_2(x^2)" alt="A(x)=A_1(x2)+xA_2(x2)"><br> 将<img src="https://math.jianshu.com/math?formula=\\omega_n^k" alt="mega_n^k">代入上式：<br><img src="https://math.jianshu.com/math?formula=\\begin{aligned} A(\\omega_n^k)%26%3DA_1(\\omega_n^{2k})%2B\\omega_n^kA_2(\\omega_n^{2k})\\\\ %26%3DA_1(\\omega_{\\frac{n}{2}}^k)%2B\\omega_n^kA_2(\\omega_{\\frac{n}{2}}^k) \\end{aligned}" alt="egin{aligned} A(mega_nk)&amp;=A_1(\\omega_n{2k})+mega_nkA_2(\\omega_n{2k}) &amp;=A_1(mega_{rac{n}{2}}k)+\\omega_nkA_2(mega_{rac{n}{2}}^k) nd{aligned}"><br> 将<img src="https://math.jianshu.com/math?formula=\\omega_n^{k%2B\\frac{n}{2}}" alt="mega_n^{k+rac{n}{2}}">代入上式：<br><img src="https://math.jianshu.com/math?formula=\\begin{aligned} A(\\omega_n^{k%2B\\frac{n}{2}})%26%3DA_1(\\omega_{n}^{2k%2Bn})%2B\\omega_n^{k%2B\\frac{n}{2}}A_2(\\omega_n^{2k%2Bn})\\\\ %26%3DA_1(\\omega_n^n\\times \\omega_n^{2k})-\\omega_n^kA_2(\\omega_n^n\\times \\omega_n^{2k})\\\\ %26%3DA_1(\\omega_n^{2k})-\\omega_n^kA_2(\\omega_n^{2k})\\\\ %26%3DA_1(\\omega_{\\frac{n}{2}}^k)-\\omega_n^kA_2(\\omega_{\\frac{n}{2}}^k) \\end{aligned}" alt="egin{aligned} A(mega_n{k+\\frac{n}{2}})&amp;=A_1(\\omega_{n}{2k+n})+mega_n{k+\\frac{n}{2}}A_2(\\omega_n{2k+n}) &amp;=A_1(mega_n^nimes mega_n{2k})-\\omega_nkA_2(mega_n^nimes mega_n^{2k}) &amp;=A_1(mega_n{2k})-\\omega_nkA_2(mega_n^{2k}) &amp;=A_1(mega_{rac{n}{2}}k)-\\omega_nkA_2(mega_{rac{n}{2}}^k) nd{aligned}"><br> 由此可以发现，<img src="https://math.jianshu.com/math?formula=A(\\omega_n^k)" alt="A(mega_n^k)">和<img src="https://math.jianshu.com/math?formula=A(\\omega_n^{k%2B\\frac{n}{2}} )" alt="A(mega_n^{k+rac{n}{2}} )">在计算的过程中只有一个符号不同，因此在进行枚举计算<img src="https://math.jianshu.com/math?formula=A(\\omega_n^k)" alt="A(mega_n^k)">时即可直接得到<img src="https://math.jianshu.com/math?formula=A(\\omega_n^{k%2B\\frac{n}{2}} )" alt="A(mega_n^{k+rac{n}{2}} )">的值，利用这种方法进行分治，便可以将复杂度降至<img src="https://math.jianshu.com/math?formula=O(nlogn)" alt="O(nlogn)">。</p><h3 id="逆傅里叶变换ifft" tabindex="-1"><a class="header-anchor" href="#逆傅里叶变换ifft" aria-hidden="true">#</a> 逆傅里叶变换IFFT</h3><p>利用上述的方法得到了乘积多项式的点值表示法，那么现在需要解决的问题时如何将点值表示法再转换回系数表示法。</p><p>假设得到多项式的FFT点值表示为<img src="https://math.jianshu.com/math?formula=(y_0%2Cy_1%2Cy_2%2C\\cdots %2Cy_{n-1})" alt="(y_0,y_1,y_2,dots ,y_{n-1})">，其系数表示为<img src="https://math.jianshu.com/math?formula=(a_0%2Ca_1%2Ca_2%2C\\cdots %2Ca_{n-1})" alt="(a_0,a_1,a_2,dots ,a_{n-1})">，根据FFT原理，<img src="https://math.jianshu.com/math?formula=y_k" alt="y_k">可如下表示：<br><img src="https://math.jianshu.com/math?formula=y_k%3D\\sum_{i%3D0}^{n-1}a_i(\\omega_n^k)^i" alt="y_k=um_{i=0}{n-1}a_i(\\omega_nk)^i"><br> 取<img src="https://math.jianshu.com/math?formula=\\omega_n^k" alt="mega_n^k">的<strong>共轭复数</strong><img src="https://math.jianshu.com/math?formula=\\omega_n^{-k}" alt="mega_n^{-k}">，如下定义向量<img src="https://math.jianshu.com/math?formula=(c_0%2Cc_1%2Cc_2%2C\\cdots %2Cc_{n-1})" alt="(c_0,c_1,c_2,dots ,c_{n-1})">：<br><img src="https://math.jianshu.com/math?formula=c_k%3D\\sum_{i%3D0}^{n-1}y_i(\\omega_n^{-k})^i" alt="c_k=um_{i=0}{n-1}y_i(\\omega_n{-k})^i"><br> 那么由定义可以推导出如下的公式：</p><div style="text-align:center;"><img src="'+n+'" alt="ASIC Flow" width="200"><h4>图2 FFT</h4></div><p>对于复平面上的单位根<img src="https://math.jianshu.com/math?formula=\\omega_n^k" alt="mega_n^k">，有如下的性质：<br><img src="https://math.jianshu.com/math?formula=\\begin{aligned} \\sum_{i%3D0}^{n-1}(\\omega_n^{j-k})^i%26%3D0\\quad(j\\neq k)\\\\ \\sum_{i%3D0}^{n-1}(\\omega_n^{j-k})^i%26 %3D\\omega_n^ 0%3D1 \\quad (j%3D k ) \\end{aligned}" alt="egin{aligned} um_{i=0}{n-1}(\\omega_n{j-k})^i&amp;=0uad(jeq k) um_{i=0}{n-1}(\\omega_n{j-k})^i&amp; =mega_n^ 0=1 uad (j= k ) nd{aligned}"><br> 因此可以得到：<br><img src="https://math.jianshu.com/math?formula=\\begin{aligned} %26c_k%3Dna_k\\\\ %26a_k%3D\\frac{c_k}{n} \\end{aligned}" alt="egin{aligned} &amp;c_k=na_k &amp;a_k=rac{c_k}{n} nd{aligned}"><br> 因此，利用FFT得到了多项式的点值表示后只需要将变量换为原本选定的单位根的共轭复数再进行一次FFT就能得到多项式的系数表示。</p><p>这里需要说明一个问题，我们以上的讨论都是建立在**<img src="https://math.jianshu.com/math?formula=n" alt="n">为<img src="https://math.jianshu.com/math?formula=2" alt="2">的幂次<strong>的条件下的，那么当<img src="https://math.jianshu.com/math?formula=n" alt="n">不是<img src="https://math.jianshu.com/math?formula=2" alt="2">的幂次时需要</strong>将<img src="https://math.jianshu.com/math?formula=n" alt="n">扩大为大于<img src="https://math.jianshu.com/math?formula=n" alt="n">的最小的<img src="https://math.jianshu.com/math?formula=2" alt="2">的幂次**，在进行逆傅里叶变换时，通过上述的推导可以发现，当我们计算的<img src="https://math.jianshu.com/math?formula=c_k" alt="c_k">中<img src="https://math.jianshu.com/math?formula=k" alt="k">的值大于原本的<img src="https://math.jianshu.com/math?formula=n" alt="n">时，就不存在<img src="https://math.jianshu.com/math?formula=j%3Dk" alt="j=k">的情况了，因此求得的<img src="https://math.jianshu.com/math?formula=a_k" alt="a_k">为<img src="https://math.jianshu.com/math?formula=0" alt="0">，表示该多项式的<img src="https://math.jianshu.com/math?formula=k" alt="k">次项系数为<img src="https://math.jianshu.com/math?formula=0" alt="0">。</p><h2 id="但是问题到这里并没有结束" tabindex="-1"><a class="header-anchor" href="#但是问题到这里并没有结束" aria-hidden="true">#</a> 但是问题到这里并没有结束</h2><p>当有的毒瘤数据范围非常大的时候，用递归进行计算时，大量的递归会造成栈溢出，那么是否有不用递归的做法？</p><h2 id="fft的迭代实现" tabindex="-1"><a class="header-anchor" href="#fft的迭代实现" aria-hidden="true">#</a> FFT的迭代实现</h2><p>对于这样一个序列<img src="https://math.jianshu.com/math?formula=(a_0%2Ca_1%2Ca_2%2Ca_3%2Ca_4%2Ca_5%2Ca_6%2Ca_7)" alt="(a_0,a_1,a_2,a_3,a_4,a_5,a_6,a_7)">，我们观察对其进行二分的过程：</p><div style="text-align:center;"><img src="'+s+`" alt="ASIC Flow" width="200"><h4>图3 FFT迭代</h4></div><p>我们发现了一个神奇的性质，在对这个序列进行二分以后的序列的二进制可以由原序列的二进制进行翻转得到，那么我们可以利用这个性质，用一个<img src="https://math.jianshu.com/math?formula=O(n)" alt="O(n)">的方法可以直接得到最终的序列，从而省去了递归的过程，用最终的序列反向递推实现即可。</p><h3 id="rader算法" tabindex="-1"><a class="header-anchor" href="#rader算法" aria-hidden="true">#</a> Rader算法</h3><p><strong>Rader算法</strong>即为实现上述操作的一种算法，对于<img src="https://math.jianshu.com/math?formula=N" alt="N">个数，我们把递增自然数<img src="https://math.jianshu.com/math?formula=(0%2C1%2C2%2C3%2C\\cdots)" alt="(0,1,2,3,dots)">称为顺序数列；对顺序数列中的每一个数，将其二进制倒序后转化为十进制，称为倒序数列。<br> 对于一个顺序数列，第<img src="https://math.jianshu.com/math?formula=i" alt="i">个数的二进制可以视为将第<img src="https://math.jianshu.com/math?formula=i%2F2" alt="i/2">（这里是整除）个数的二进制左移一位，再根据<img src="https://math.jianshu.com/math?formula=i" alt="i">的奇偶性对其末尾加<img src="https://math.jianshu.com/math?formula=1" alt="1">或者不加<img src="https://math.jianshu.com/math?formula=1" alt="1">。<br> 那么要得到它的倒序数列，只需要将这个操作反向进行即可，即第<img src="https://math.jianshu.com/math?formula=i" alt="i">个数的二进制可以视为将第<img src="https://math.jianshu.com/math?formula=i%2F2" alt="i/2">个数的二进制右移一位，再根据<img src="https://math.jianshu.com/math?formula=i" alt="i">的奇偶性对其最高加<img src="https://math.jianshu.com/math?formula=1" alt="1">或者不加<img src="https://math.jianshu.com/math?formula=1" alt="1">，这里最高位即为第<img src="https://math.jianshu.com/math?formula=\\log_{2}n" alt="og_{2}n">位。</p><h3 id="迭代进行fft-蝴蝶变换" tabindex="-1"><a class="header-anchor" href="#迭代进行fft-蝴蝶变换" aria-hidden="true">#</a> 迭代进行FFT（蝴蝶变换）</h3><p>利用Rader算法求得了递推序列，那么如何通过迭代得到最终的答案？<br> 这其实跟迭代实现01背包的做法思路差不多，对于求<img src="https://math.jianshu.com/math?formula=A(x)" alt="A(x)">在<img src="https://math.jianshu.com/math?formula=n" alt="n">次单位根的各幂次的点值时，<img src="https://math.jianshu.com/math?formula=m%3Dn%2F2" alt="m=n/2">次单位根的各幂次在<img src="https://math.jianshu.com/math?formula=A_1" alt="A_1">或<img src="https://math.jianshu.com/math?formula=A_2" alt="A_2">处的点值已经被计算并且储存在了<img src="https://math.jianshu.com/math?formula=A" alt="A">数组中，那么在下一层的迭代过程中直接使用<img src="https://math.jianshu.com/math?formula=A" alt="A">数组存储的答案继续进行迭代计算即可。</p><h2 id="迭代优化fft代码实现" tabindex="-1"><a class="header-anchor" href="#迭代优化fft代码实现" aria-hidden="true">#</a> 迭代优化FFT代码实现</h2><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">300010</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token function">acos</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Complex</span>
<span class="token punctuation">{</span>
    <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
    Complex <span class="token keyword">operator</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>x <span class="token operator">+</span> t<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> t<span class="token punctuation">.</span>y<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Complex <span class="token keyword">operator</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>x <span class="token operator">-</span> t<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> t<span class="token punctuation">.</span>y<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Complex <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Complex<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>x <span class="token operator">*</span> t<span class="token punctuation">.</span>x <span class="token operator">-</span> y <span class="token operator">*</span> t<span class="token punctuation">.</span>y<span class="token punctuation">,</span> x <span class="token operator">*</span> t<span class="token punctuation">.</span>y <span class="token operator">+</span> y <span class="token operator">*</span> t<span class="token punctuation">.</span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> rev<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> bit<span class="token punctuation">,</span> tot<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fft</span><span class="token punctuation">(</span>Complex a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> inv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> rev<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>rev<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> mid <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> mid <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> w1 <span class="token operator">=</span> <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token function">cos</span><span class="token punctuation">(</span>PI <span class="token operator">/</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> inv <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>PI <span class="token operator">/</span> mid<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> i <span class="token operator">+=</span> mid <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">auto</span> wk <span class="token operator">=</span> <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> mid<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">,</span> wk <span class="token operator">=</span> wk <span class="token operator">*</span> w1<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">auto</span> x <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> wk <span class="token operator">*</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">+</span> mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
                a<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">+</span> mid<span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%lf&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%lf&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n <span class="token operator">+</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> bit <span class="token operator">++</span><span class="token punctuation">;</span>
    tot <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
        rev<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>rev<span class="token punctuation">[</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>bit <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fft</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fft</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">fft</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">+</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d &quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">/</span> tot <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,43),l=[i];function u(m,r){return p(),o("div",null,l)}const _=t(e,[["render",u],["__file","FFT.html.vue"]]);export{_ as default};
