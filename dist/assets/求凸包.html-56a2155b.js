const a=JSON.parse('{"key":"v-2060a2e2","path":"/en/train/eda/algorithm-data/Part_7_algorithm/7_3_math/%E6%B1%82%E5%87%B8%E5%8C%85.html","title":"7.3.11 求凸包","lang":"en-US","frontmatter":{"title":"7.3.11 求凸包","order":11},"headers":[{"level":2,"title":"1. JarvisMarch 算法","slug":"_1-jarvismarch-算法","link":"#_1-jarvismarch-算法","children":[]},{"level":2,"title":"2. Graham 算法","slug":"_2-graham-算法","link":"#_2-graham-算法","children":[]},{"level":2,"title":"3. Andrew 算法","slug":"_3-andrew-算法","link":"#_3-andrew-算法","children":[]}],"git":{"createdTime":1723131714000,"updatedTime":1723131714000,"contributors":[{"name":"Xingquan-Li","email":"fzulxq@gmail.com","commits":1}]},"readingTime":{"minutes":9.88,"words":2963},"filePathRelative":"en/train/eda/algorithm-data/Part_7_algorithm/7_3_math/求凸包.md","localizedDate":"August 8, 2024","excerpt":"<h1> 凸包</h1>\\n<p>由凸包点集的性质我们可知凸包算法的思想，按顺序构建凸包点集，并且维护它，直到完成点的遍历。</p>\\n<p>其精髓在于顺序和维护该性质。网上的算法代码第一步往往是寻找边角点和其相邻点，因为边角点必会在凸包点集中。但是其实多此一举，由于需要顺序，我们先将所有点按坐标排列，排列完的最初元素也必为边角点。</p>\\n<p>首先在凸包点集中加入排序后的前两个点，接下来我们在凸包点集中取出末尾两个点，以这两点构成的边对接下来的点进行处理。每次处理通过向量判断是否在边的内侧，若在内侧则跳过这个点，视为已处理，若在外侧则说明我们所用的边并不是凸包所要的边，故抛弃当前凸包点集的最后一个点，然后再取末尾两个点，进行迭代判断，直到将该点加入。由此遍历完即产生凸包点集。（雾）应该正序遍历完倒序遍历一次回到起始点，才是一个封闭凸包，不然只有一半</p>","copyright":{"author":"iEDA","license":"GPL-3.0"}}');export{a as data};
