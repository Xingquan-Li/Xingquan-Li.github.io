const t=JSON.parse('{"key":"v-b0c9455e","path":"/train/eda/algorithm-data/Part_7_algorithm/7_4_graph/7_4_3_DFS%E7%AE%97%E6%B3%95%E4%B8%8EBFS%E7%AE%97%E6%B3%95.html","title":"7.4.3 DFS和BFS","lang":"zh-CN","frontmatter":{"title":"7.4.3 DFS和BFS","order":3},"headers":[],"git":{"createdTime":1721900327000,"updatedTime":1721900327000,"contributors":[{"name":"simintao","email":"simintao@126.com","commits":1}]},"readingTime":{"minutes":11.33,"words":3399},"filePathRelative":"train/eda/algorithm-data/Part_7_algorithm/7_4_graph/7_4_3_DFS算法与BFS算法.md","localizedDate":"2024年7月25日","excerpt":"<h1> DFS算法</h1>\\n<p>DFS算法即：Depth First Search，深度优先搜索。这个算法的关键是解决“当下如何做”，至于下一步如何做和“当下如何做”是一样的，该算法从一个状态DFS(n)转移到下一个状态DFS（n+1），直到状态无法转移即到达临界点，然后回退到上一个状态，在上一个状态的基础上继续遍历其他状态，如此不断重复，直到找到最终解。如果算法有M个状态，每个状态有N种可能可以尝试，那么总的尝试次数是N^M 即M个N相乘。</p>\\n<p>算法的关注点：</p>\\n<ol>\\n<li>当下如何做，当下的状态如何处理</li>\\n<li>如何转移到下一个状态，下一个状态有哪些可能？</li>\\n<li>临界条件设定和dfs结束条件的设定以及处理</li>\\n<li>标志位的设置和复位，标记资源被占用，以及当前使用后及时释放，留给下一次使用。</li>\\n</ol>","copyright":{"author":"iEDA","license":"GPL-3.0"}}');export{t as data};
