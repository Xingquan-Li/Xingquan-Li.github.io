import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as t,f as n}from"./app-1ed3f6c2.js";const a={},o=n(`<h2 id="_1-introduction" tabindex="-1"><a class="header-anchor" href="#_1-introduction" aria-hidden="true">#</a> 1. Introduction</h2><p>For modern very large-scale digital integrated circuit (VLSI) design, electronic design automation (EDA) is a crucial tool. &quot;To be continued&quot;</p><h3 id="_1-1-foundation-of-chip-design" tabindex="-1"><a class="header-anchor" href="#_1-1-foundation-of-chip-design" aria-hidden="true">#</a> 1.1 Foundation of Chip Design</h3><h4 id="_1-1-1-chip-design-hierarchy" tabindex="-1"><a class="header-anchor" href="#_1-1-1-chip-design-hierarchy" aria-hidden="true">#</a> 1.1.1 Chip Design Hierarchy</h4><p>From a hierarchical perspective, chip design can be generally divided into the following levels:</p><ul><li><p>System level: The design of the chip system architecture, with independent and complete functional IP modules</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Port* compute_optimal_route_for_packet (Packet_t *packet, Channel_t *channel){
    static Queue_t *packet_queue; packet_queue = add_packet(packet_queue, packet); ......
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>Register level: The functionality is implemented using registers to form RTL code</p><img src="https://images.gitee.com/uploads/images/2022/0525/180936_4c445e28_8273072.png" alt="6" style="zoom:25%;"></li><li><p>Gate level: Through the synthesis tool, the RTL code is transformed into a circuit, and then the circuit is mapped into a gate-level netlist formed by GTech or standard cell libraries;</p><img src="https://images.gitee.com/uploads/images/2022/0525/180919_5542498c_8273072.png" alt="6" style="zoom:25%;"></li><li><p>Transistor level: Each cell in the standard cell library has been pre-designed, and the key component is the transistor, which is also the most atomic level;</p><img src="https://images.gitee.com/uploads/images/2022/0525/181001_adc00885_8273072.png" alt="6" style="zoom:25%;"></li><li><p>Layout level: After the physicalization of the gate-level netlist, a layout GDS is formed, which is a blueprint for chip manufacturing;</p><img src="https://images.gitee.com/uploads/images/2022/0525/181304_6fe49636_8273072.png" alt="6" style="zoom:25%;"></li><li><p>Mask level: Chip manufacturers will design masks based on the layout layers to guide the lithography machine for exposure. Advanced processes may even require multiple exposures;</p><img src="https://images.gitee.com/uploads/images/2022/0525/181100_d80871ac_8273072.png" alt="6" style="zoom:25%;"></li></ul><h4 id="_1-1-2-design-automation-content" tabindex="-1"><a class="header-anchor" href="#_1-1-2-design-automation-content" aria-hidden="true">#</a> 1.1.2 Design Automation Content</h4><p>The entire chip design process can be generally summarized as the following abstract process:</p><ul><li>Specification formulation: According to product requirements, formulate corresponding specifications</li><li>Architecture design: Based on the specification requirements, design the chip architecture, divide the system functional modules, define the BUS structure, system model, manufacturing packaging and board requirements, and output the design document;</li><li>Function implementation and verification: Implement the corresponding RTL code for each functional module and conduct functional simulation verification. During this period, mainly rely on Debug tools and waveform simulation tools, and output RTL-level Verilog code. If necessary, each IP functional module needs to be integrated into the SOC and functionally verified. For verification, it can be completed with the help of FPGA or hardware emulation;</li><li>Logic synthesis: Logically compile the RTL code to form a state machine or truth table, then conduct logical optimization design to form a GTech circuit, and then obtain the netlist through process library mapping, and conduct circuit-level simulation and formal verification, and output Netlist-level Verilog code. After synthesis, perform DFT and insert some test modules;</li><li>Unit library design: The process library obtained from the Foundary will basically contain IO, Memory and some IPs, as well as PDK and unit libraries. However, the unit library can be further optimized and designed. First, design the unit model, conduct the unit circuit layout design, extract the parameters of the unit, and conduct physical verification;</li><li>Physical design: For the netlist obtained through synthesis, steps such as Floorplan design, placement, clock tree synthesis, routing, and ECO are required, and finally, the GDS layout file is obtained. Of course, in order to achieve the expected PPA indicators and meet the design rules, physical design often requires multiple iterations. In addition, each step of physical design also needs to undergo formal verification to confirm the correctness of the function;</li><li>Sign-off analysis: During the logic synthesis and physical design processes, parameters, timing, power consumption, IR drop, power and signal integrity, etc. of the circuit and layout need to be extracted and analyzed to ensure that the obtained circuit and layout meet the design specification constraints;</li><li>Physical verification: After obtaining the GDS layout, in addition to sign-off analysis, physical structure verification is also required, mainly including: design rule check (DRC), electrical rule check (ERC), layout versus schematic (LVS), etc. Afterwards, a final simulation is also required to ensure the correctness of the entire layout function;</li><li>Layout processing: After completing the physical verification, the chip design link is basically completed. Next, the layout needs to be handed over to the Foundary to open the mask (Mask). The GDS layout needs to be further optimized, perform OPC and RET, in order to enhance the resolution and reduce production deformation errors, and then be used to produce the Mask;</li><li>Manufacturing, packaging and testing: Mainly completed by Foudary and packaging and testing factories, and return the wafers;</li><li>PCB: After completing the above steps, a chip can basically be obtained, and it can be integrated into the required PCB for practical verification and use. The PCB-level board also involves issues such as layout and routing;</li></ul><img src="https://images.gitee.com/uploads/images/2022/0526/104146_98f059c1_8273072.png" alt="6" style="zoom:25%;"><p>Figure 1.1.1 Main EDA tool steps</p><img src="https://images.gitee.com/uploads/images/2022/0530/145123_9b414b6d_8273072.png" alt="6" style="zoom:30%;"><p>Figure 1.1.2 Main EDA tool steps</p><p>Throughout the chip design process, the main EDA tools generated and their classifications and contents can be summarized into the following five major aspects:</p><ul><li><strong>Design synthesis</strong>: The design links mainly include high-level synthesis, logic synthesis, physical design, packaging design, and PCB design</li><li><strong>Simulation</strong>: The simulation links mainly include: TCAD, transistor simulation, logic simulation, hardware simulation, field solver</li><li><strong>Verification and testing</strong>: The verification and testing links mainly include functional verification, formal verification, equivalence check, ATPG, BIST, physical verification</li><li><strong>Analysis and inspection</strong>: The analysis links mainly include cross-clock domain, parasitic extraction, (static) timing analysis, power consumption analysis, temperature analysis, voltage drop analysis, signal/power integrity analysis</li><li><strong>Mask preparation</strong>: The mask links mainly include layout decomposition, OPC, RET, and mask generation</li></ul><img src="https://images.gitee.com/uploads/images/2022/0525/175128_fb471b46_8273072.png" alt="6" style="zoom:35%;"><p>Figure 1.1.3 Main EDA tool steps</p><p>The main research and development focus of the iEDA research group is on the chip logic synthesis, physical design, sign-off analysis and physical verification links, as shown in the green part of the following figure:</p><img src="https://images.gitee.com/uploads/images/2022/0530/150057_1b7674b3_8273072.png" alt="6" style="zoom:30%;"><p>Figure 1.1.4 Main EDA tool steps</p><h3 id="_1-2-design-requirements-and-goals" tabindex="-1"><a class="header-anchor" href="#_1-2-design-requirements-and-goals" aria-hidden="true">#</a> 1.2 Design Requirements and Goals</h3><ul><li><p>Full design process: Support 110nm/55nm/28nm chip RTL to GDS, and conduct sign-off analysis and physical verification</p><ul><li>WLM: Wire load model, evaluate the total wire length of the netlist after logic synthesis based on the fanout of the net, relying on the WLM information in.lib</li><li>HPWL: Half-perimeter wire length, approximate the wiring length of the net by using the half-perimeter of the bounding rectangle formed by the pins of the net</li><li>Clique, Star, Bound2Bound: Commonly used wire length approximation models in the secondary parsing method of placement</li><li>Steiner tree: Construct Steiner points for the net, and use the length of the Steiner tree as the wiring length of the net, mainly including HVTree/FLUTE</li><li>Driver to load: Calculate the L-shaped length from the driver of the net to the specified sink pin</li><li>Routing: Evaluate the total wire length in the global routing and detailed routing stages</li></ul></li><li><p>Open source and openness:</p><ul><li>Placement: Evaluate the timing at the placement stage, and support obtaining the timing information of the specified pin at the same time, relying on iSTA</li><li>Routing: Evaluate the timing at the routing stage, relying on iSTA</li></ul></li><li><p>Software decoupling:</p><ul><li>Cell density: Divide the core area into several bins and calculate the density of instances in each bin</li><li>Pin density: Divide the core area into several bins and calculate the number of pins in each bin</li><li>BBox density: Divide the core area into several bins and calculate the density of nets in each bin</li><li>GR congestion: Divide the die area into several tiles and calculate the overflow value of each tile, relying on iRT</li></ul></li><li><p>Complete documentation:</p></li><li><p>Performance optimization:</p></li><li><p>Intelligence:</p></li><li><p>Community ecology:</p></li></ul>`,22),s=[o];function l(r,c){return i(),t("div",null,s)}const u=e(a,[["render",l],["__file","iEDA-design-doc.html.vue"]]);export{u as default};
