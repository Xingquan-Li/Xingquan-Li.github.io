const t=JSON.parse('{"key":"v-fedb9626","path":"/train/eda/algorithm-data/Part_6-data_structure/6_7_partition_tree.html","title":"6.7 划分树","lang":"zh-CN","frontmatter":{"title":"6.7 划分树","order":7},"headers":[],"git":{"createdTime":1721213548000,"updatedTime":1721213548000,"contributors":[{"name":"Xingquan-Li","email":"fzulxq@gmail.com","commits":1}]},"readingTime":{"minutes":3.82,"words":1145},"filePathRelative":"train/eda/algorithm-data/Part_6-data_structure/6_7_partition_tree.md","localizedDate":"2024年7月17日","excerpt":"<h1> 划分树</h1>\\n<p>划分树是一种基于线段树的数据结构，也利用了分治的思想，却比线段树高效很多，这是为什么？因为划分树又多了一个性质：在划分时不是随意划分，也不是排序后直接划分（因为这样会破坏原有结构），而是排序后仍保持原来的相对顺序再分到左右子树。</p>\\n<p>具体实现方法：</p>\\n<p>整个过程分为建树和查询两个阶段：</p>\\n<div style=\\"text-align:center;\\">\\n  <img src=\\"/res/images/eda_datastructure/PartitionTree_1.webp\\" alt=\\"ASIC Flow\\" width=\\"200\\">\\n  <h4>图1 划分树</h4>\\n</div>","copyright":{"author":"iEDA","license":"GPL-3.0"}}');export{t as data};
