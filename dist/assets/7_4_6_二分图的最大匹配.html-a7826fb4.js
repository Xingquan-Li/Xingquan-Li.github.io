import{_ as n,a as s,b as a,c as t,d as p,e as o,f as e,g as c,h as i,i as l}from"./graph_15-956c15b2.js";import{_ as u}from"./plugin-vue_export-helper-c27b6911.js";import{o as k,c as r,f as d}from"./app-1ed3f6c2.js";const v={},m=d('<h1 id="二分图的最大匹配" tabindex="-1"><a class="header-anchor" href="#二分图的最大匹配" aria-hidden="true">#</a> 二分图的最大匹配</h1><p>这篇文章讲无权二分图（unweighted bipartite graph）的最大匹配（maximum matching）和完美匹配（perfect matching），以及用于求解匹配的匈牙利算法（Hungarian Algorithm）；不讲带权二分图的最佳匹配。</p><p><strong>二分图</strong>：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 UU 和VV ，使得每一条边都分别连接UU、VV中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p><p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p><div style="text-align:center;"><img src="'+n+'" alt="ASIC Flow" width="200"><h4>图1 二分图</h4></div><div style="text-align:center;"><img src="'+s+'" alt="ASIC Flow" width="200"><h4>图2 二分图</h4></div><div style="text-align:center;"><img src="'+a+'" alt="ASIC Flow" width="200"><h4>图3 二分图匹配</h4></div><div style="text-align:center;"><img src="'+t+'" alt="ASIC Flow" width="200"><h4>图4 二分图匹配</h4></div><p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p><p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p><p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p><p>举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是<strong>完美匹配</strong>问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是<strong>最大匹配</strong>问题。</p><div style="text-align:center;"><img src="'+p+'" alt="ASIC Flow" width="200"><h4>图5 最大匹配</h4></div><p>基本概念讲完了。求解最大匹配问题的一个算法是<strong>匈牙利算法</strong>，下面讲的概念都为这个算法服务。</p><div style="text-align:center;"><img src="'+o+'" alt="ASIC Flow" width="200"><h4>图6 匈牙利算法</h4></div><p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图中的一条增广路如图所示（图中的匹配点均用红色标出）：</p><div style="text-align:center;"><img src="'+e+'" alt="ASIC Flow" width="200"><h4>图7 增广路</h4></div><p>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是<strong>改进匹配</strong>。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。</p><p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。</p><p><strong>匈牙利树</strong>一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，如图的一棵 BFS 树：</p><div style="text-align:center;"><img src="'+c+'" alt="ASIC Flow" width="200"><h4>图8 匈牙利树</h4></div><div style="text-align:center;"><img src="'+i+'" alt="ASIC Flow" width="200"><h4>图9 匈牙利树</h4></div><div style="text-align:center;"><img src="'+l+`" alt="ASIC Flow" width="200"><h4>图10 匈牙利树</h4></div><p>这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。</p><p>下面给出<strong>匈牙利算法</strong>的 DFS 和 BFS 版本的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 顶点、边的编号均从 0 开始</span>
<span class="token comment">// 邻接表储存</span>

<span class="token keyword">struct</span> <span class="token class-name">Edge</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> from<span class="token punctuation">;</span>
    <span class="token keyword">int</span> to<span class="token punctuation">;</span>
    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>

    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">from</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> G<span class="token punctuation">[</span>__maxNodes<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* G[i] 存储顶点 i 出发的边的编号 */</span>
vector<span class="token operator">&lt;</span>Edge<span class="token operator">&gt;</span> edges<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator iterator_t<span class="token punctuation">;</span>
<span class="token keyword">int</span> num_nodes<span class="token punctuation">;</span>
<span class="token keyword">int</span> num_left<span class="token punctuation">;</span>
<span class="token keyword">int</span> num_right<span class="token punctuation">;</span>
<span class="token keyword">int</span> num_edges<span class="token punctuation">;</span>
<span class="token keyword">int</span> matching<span class="token punctuation">[</span>__maxNodes<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 存储求解结果 */</span>
<span class="token keyword">int</span> check<span class="token punctuation">[</span>__maxNodes<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>iterator_t i <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 对 u 的每个邻接点</span>
        <span class="token keyword">int</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>check<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 要求不在交替路中</span>
            check<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 放入交替路</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matching<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">dfs</span><span class="token punctuation">(</span>matching<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功</span>
                matching<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
                matching<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 不存在增广路，返回失败</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">hungarian</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>matching<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>matching<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> u <span class="token operator">&lt;</span> num_left<span class="token punctuation">;</span> <span class="token operator">++</span>u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>matching<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">memset</span><span class="token punctuation">(</span>check<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>check<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token operator">++</span>ans<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> Q<span class="token punctuation">;</span>
<span class="token keyword">int</span> prev<span class="token punctuation">[</span>__maxNodes<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">Hungarian</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>matching<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>matching<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>check<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>check<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>num_left<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>matching<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 设 i 为路径起点</span>
            <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 尚未找到增广路</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> u <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>iterator_t ix <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ix <span class="token operator">!=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>flag<span class="token punctuation">;</span> <span class="token operator">++</span>ix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">int</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span><span class="token operator">*</span>ix<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        check<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
                        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>matching<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>matching<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 此点为匹配点</span>
                            prev<span class="token punctuation">[</span>matching<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 找到未匹配点，交替路变为增广路</span>
                            flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                            <span class="token keyword">int</span> d<span class="token operator">=</span>u<span class="token punctuation">,</span> e<span class="token operator">=</span>v<span class="token punctuation">;</span>
                            <span class="token keyword">while</span> <span class="token punctuation">(</span>d <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token keyword">int</span> t <span class="token operator">=</span> matching<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">;</span>
                                matching<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                                matching<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
                                d <span class="token operator">=</span> prev<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">;</span>
                                e <span class="token operator">=</span> t<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>matching<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>ans<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>匈牙利算法的要点如下</strong></p><ol><li>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。 <ol><li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li><li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li></ol></li><li>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 <code>prev</code> 数组。</li></ol><p><strong>性能比较</strong></p><p>两个版本的时间复杂度均为O(V⋅E)O(V⋅E)。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。</p><p>补充定义和定理：</p><p><strong>最大匹配数</strong>：最大匹配的匹配边的数目</p><p><strong>最小点覆盖数</strong>：选取最少的点，使任意一条边至少有一个端点被选择</p><p><strong>最大独立数</strong>：选取最多的点，使任意所选两点均不相连</p><p><strong>最小路径覆盖数</strong>：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p><p>定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）</p><p>定理2：最大匹配数 = 最大独立数</p><p>定理3：最小路径覆盖数 = 顶点数 - 最大匹配数</p>`,39),b=[m];function g(h,w){return k(),r("div",null,b)}const S=u(v,[["render",g],["__file","7_4_6_二分图的最大匹配.html.vue"]]);export{S as default};
