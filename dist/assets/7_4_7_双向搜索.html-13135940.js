const e=JSON.parse('{"key":"v-23a9b71f","path":"/train/eda/algorithm-data/Part_7_algorithm/7_4_graph/7_4_7_%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2.html","title":"7.4.7 双向搜索","lang":"zh-CN","frontmatter":{"title":"7.4.7 双向搜索","order":7},"headers":[{"level":2,"title":"双向同时搜索","slug":"双向同时搜索","link":"#双向同时搜索","children":[]},{"level":2,"title":"Meet in the middle","slug":"meet-in-the-middle","link":"#meet-in-the-middle","children":[]}],"git":{"createdTime":1721900327000,"updatedTime":1721900327000,"contributors":[{"name":"simintao","email":"simintao@126.com","commits":1}]},"readingTime":{"minutes":3,"words":901},"filePathRelative":"train/eda/algorithm-data/Part_7_algorithm/7_4_graph/7_4_7_双向搜索.md","localizedDate":"2024年7月25日","excerpt":"<h2> 双向同时搜索</h2>\\n<p>双向同时搜索的基本思路是从状态图上的起点和终点同时开始进行 广搜 或 深搜。如果发现搜索的两端相遇了，那么可以认为是获得了可行解。</p>\\n<p>双向广搜的步骤：</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>将开始结点和目标结点加入队列 q\\n标记开始结点为 1\\n标记目标结点为 2\\nwhile (队列 q 不为空)\\n{\\n  从 q.front() 扩展出新的 s 个结点\\n  \\n  如果 新扩展出的结点已经被其他数字标记过\\n    那么 表示搜索的两端碰撞\\n    那么 循环结束\\n  \\n  如果 新的 s 个结点是从开始结点扩展来的\\n    那么 将这个 s 个结点标记为 1 并且入队 q \\n    \\n  如果 新的 s 个结点是从目标结点扩展来的\\n    那么 将这个 s 个结点标记为 2 并且入队 q\\n}\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","copyright":{"author":"iEDA","license":"GPL-3.0"}}');export{e as data};
