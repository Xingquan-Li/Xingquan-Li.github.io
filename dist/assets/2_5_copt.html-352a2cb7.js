import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as a,c as p,d as e,e as t,a as l,f as d}from"./app-1ed3f6c2.js";const n={},i=d('<p>时钟树综合是构建和优化时钟树的过程，其方式是使时钟均匀分布，并且每个顺序元素的时钟都在目标全局偏差限制内。要构建时钟树，我们必须向 APR 工具提供某些约束作为输入，这些约束通常称为时钟约束，对于 Innovus 工具，此约束文件通常称为 ccopt 文件。</p><p>在本文中，我们将了解一些重要的时钟树约束，这些约束在每个设计中都很常用，以及它们的实际含义以及提供这些约束的原因。如今，如果您要参加物理设计的面试，且经验在0-5年之间，那么您将不可避免地面临与时钟树约束相关的问题。</p><p>时钟树约束：</p><ul><li>时钟树单元列表</li><li>首选时钟树布线层和非默认规则（NDR）</li><li>目标偏移</li><li>目标最大过渡</li><li>目标最大电容</li><li>最大扇出</li><li>单元密度</li><li>单元边界留白</li></ul><h2 id="时钟树单元列表" tabindex="-1"><a class="header-anchor" href="#时钟树单元列表" aria-hidden="true">#</a> 时钟树单元列表</h2><p>我们在时钟树构建中使用时钟反相器和时钟缓冲器。有时我们只使用时钟反相器而不使用时钟缓冲器。我们还在时钟树中使用时钟门控单元。因此，我们必须提供希望在时钟树中使用的单元列表。</p><p><code>set_ccopt_property inverter_cells {}</code></p><p><code>set_ccopt_property buffer_cells {}</code></p><p><code>set_ccopt_property clock_gating_cells {}</code></p><p><code>set_ccopt_property logic_cells {}</code></p><h2 id="首选时钟树布线层和非默认规则-ndr" tabindex="-1"><a class="header-anchor" href="#首选时钟树布线层和非默认规则-ndr" aria-hidden="true">#</a> 首选时钟树布线层和非默认规则（NDR）</h2><p>我们需要为时钟树网络提供顶部和底部首选的布线层。通常我们在这里定义主干网和叶网。将时钟连接到时序元件的时钟引脚的网络称为叶网，将时钟传递到叶网的网络称为主干网。</p><p><code>set_ccopt_property -name trunckRoute -top_preferred_layer &lt;&gt; -bottom_preferred_layer &lt;&gt; -preferred_routing_layer_effort high -non_default_rule 2w2s</code></p><p><code>set_ccopt_property -name leafRoute -top_preferred_layer &lt;&gt; -bottom_preferred_layer &lt;&gt; -preferred_routing_layer_effort high -non_default_rule 1w2s</code></p><h2 id="目标偏移" tabindex="-1"><a class="header-anchor" href="#目标偏移" aria-hidden="true">#</a> 目标偏移</h2><p>偏移平衡是时钟树优化中的挑战之一。我们将目标偏移提供为时钟树约束。PnR工具将尝试在给定的偏移限制内平衡偏移。</p><p><code>set_ccopt_property -target_skew &lt;&gt;</code></p><h2 id="目标最大过渡" tabindex="-1"><a class="header-anchor" href="#目标最大过渡" aria-hidden="true">#</a> 目标最大过渡</h2><p>我们为时钟树网络提供了时钟网的最大过渡限制。工具将尝试满足最大过渡限制。</p><p><code>set_ccopt_property -target_max_trans &lt;&gt;</code></p><h2 id="目标最大电容" tabindex="-1"><a class="header-anchor" href="#目标最大电容" aria-hidden="true">#</a> 目标最大电容</h2><p>我们为时钟树网络提供了时钟网的最大电容限制。工具将尝试分配负载电容并尝试满足最大电容限制。</p><p><code>set_ccopt_property -target_max_capacitance &lt;&gt;</code></p><h2 id="最大扇出" tabindex="-1"><a class="header-anchor" href="#最大扇出" aria-hidden="true">#</a> 最大扇出</h2><p>我们通过这个约束限制时钟树中任何实例的最大扇出。工具将尝试根据此限制构建时钟树。</p><p><code>set_ccopt_property -max_fanout &lt;&gt;</code></p><h2 id="单元密度" tabindex="-1"><a class="header-anchor" href="#单元密度" aria-hidden="true">#</a> 单元密度</h2><p>对时钟树实例设置最大单元密度限制是必需的。</p><p><code>set_ccopt_property -cell_density &lt;&gt;</code></p><h2 id="单元边界留白-halo" tabindex="-1"><a class="header-anchor" href="#单元边界留白-halo" aria-hidden="true">#</a> 单元边界留白 [Halo]</h2><p>我们需要在时钟树实例周围提供一个Halo以避免更密集的放置可能导致IR / 串扰问题。因此，我们在单元周围提供x和y方向上的单元边界留白约束。</p><p><code>set_ccopt_property -cell_halo_x &lt;&gt;</code></p><p><code>set_ccopt_property -cell_halo_y &lt;&gt;</code></p><p>这些是在构建时钟树之前提供的主要约束。还有一些其他约束，但上述章节已经解释了主要约束。下图总结了时钟树约束。</p><p>** 谢谢**</p>',35),_={href:"https://teamvlsi.com/2021/06/clock-tree-constraints-in-vlsi-ccopt-file-in-physical-design-cts-constraints.html",target:"_blank",rel:"noopener noreferrer"};function s(h,f){const r=c("ExternalLinkIcon");return a(),p("div",null,[i,e("p",null,[t("原文链接："),e("a",_,[t("https://teamvlsi.com/2021/06/clock-tree-constraints-in-vlsi-ccopt-file-in-physical-design-cts-constraints.html"),l(r)])])])}const y=o(n,[["render",s],["__file","2_5_copt.html.vue"]]);export{y as default};
