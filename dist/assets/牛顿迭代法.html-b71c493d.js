const t=JSON.parse('{"key":"v-b7c547e4","path":"/train/eda/algorithm-data/Part_7_algorithm/7_3_math/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95.html","title":"7.3.2 牛顿迭代法","lang":"zh-CN","frontmatter":{"title":"7.3.2 牛顿迭代法","order":2},"headers":[{"level":2,"title":"牛顿迭代法","slug":"牛顿迭代法-1","link":"#牛顿迭代法-1","children":[]},{"level":2,"title":"算法优缺点分析","slug":"算法优缺点分析","link":"#算法优缺点分析","children":[]},{"level":2,"title":"算法步骤","slug":"算法步骤","link":"#算法步骤","children":[]},{"level":2,"title":"示例","slug":"示例","link":"#示例","children":[]}],"git":{"createdTime":1721228251000,"updatedTime":1721278236000,"contributors":[{"name":"simintao","email":"simintao@126.com","commits":3}]},"readingTime":{"minutes":10.76,"words":3229},"filePathRelative":"train/eda/algorithm-data/Part_7_algorithm/7_3_math/牛顿迭代法.md","localizedDate":"2024年7月17日","excerpt":"<h1> 牛顿迭代法</h1>\\n<blockquote>\\n<p>牛顿法给出了任意方程求根的数值解法，而最优化问题一般会转换为求函数之间在\\"赋范线性空间\\"的距离<strong>最小点</strong>，所以，利用牛顿法去求解任意目标函数的<strong>极值点</strong>是个不错的思路。</p>\\n</blockquote>\\n<h1> 方程求根</h1>\\n<p>对于一元二次方程，求根其实很简单，只要套用求根公式就行了，但找到一个方程的求根公式（<strong>解析解</strong>）其实是很困难的，可以证明5次方程以上便没有解析解了。其他的复杂方程如偏微分方程求解更是超级困难。好在随着计算机技术的发展，解析解变的不再那么重要（至少是在工程上），取而代之的方法便是数值解法，<strong>牛顿法</strong>便是众多数值解法中的一个。<br>\\n数值法求解又叫做数值分析，主要利用逼近的思想来使数值解通过迭代计算不断接近解析解，而得出来得解就叫做<strong>数值解</strong>，在工程上，数值解只要是在精度要求范围内满足方程便是有用的。</p>","copyright":{"author":"iEDA","license":"GPL-3.0"}}');export{t as data};
